#!/usr/bin/python3
# SPDX-FileCopyrightText: 2025 Peter Lemenkov <lemenkov@gmail.com>
# SPDX-License-Identifier: MIT
"""
Erigon Watchdog v3 - Multi-failure detection with diagnostics capture

Features:
- Captures pprof goroutine dump before restart (for post-mortem analysis)
- Detects CL failures ("no CL requests") and restarts beacon-chain instead
- Detects aggregation in progress and waits instead of restarting
- Tracks restart effectiveness to detect wrong-service-restart loops
- HTTP management API for runtime configuration

Environment variables (via /etc/sysconfig/erigon_watchdog):
    REFERENCE_URL       - URL to get reference block height (required)
    LOCAL_URL           - Local Erigon RPC URL (default: http://localhost:8545)
    THRESHOLD           - Block drift threshold to trigger restart (default: 20)
    PPROF_URL           - Pprof endpoint (default: http://localhost:6060)
    EXTERNAL_CL         - Set to "1" if using external CL like Prysm (default: 0)
    CL_SERVICE          - Consensus layer service name (default: beacon-chain)
    MAX_ERIGON_RESTARTS - Max Erigon restarts before trying CL (default: 3)
    MGMT_ADDR           - Management API listen address (default: 127.0.0.1)
    MGMT_PORT           - Management API listen port (default: 8080)

Management API:
    GET  /status            - Current status (drift, threshold, restarts, etc.)
    POST /threshold/<N>     - Set threshold to N (0 = pause restarts)
    POST /threshold/default - Reset threshold to config value
"""

import json
import os
import subprocess
import sys
import time
import urllib.request
import dbus
import threading
from datetime import datetime, timedelta
from functools import partial
from http.server import HTTPServer, BaseHTTPRequestHandler
from pathlib import Path
from systemd import journal

# Ensure stdout is line-buffered for real-time logging to journald
sys.stdout.reconfigure(line_buffering=True)

# Configuration from environment
REFERENCE_URL = os.environ.get("REFERENCE_URL")
LOCAL_URL = os.environ.get("LOCAL_URL", "http://localhost:8545")
CONFIG_THRESHOLD = int(os.environ.get("THRESHOLD", "20"))
PPROF_URL = os.environ.get("PPROF_URL", "http://localhost:6060")
EXTERNAL_CL = os.environ.get("EXTERNAL_CL", "0") == "1"
CL_SERVICE = os.environ.get("CL_SERVICE", "beacon-chain")
MAX_ERIGON_RESTARTS = int(os.environ.get("MAX_ERIGON_RESTARTS", "3"))
MGMT_ADDR = os.environ.get("MGMT_ADDR", "127.0.0.1")
MGMT_PORT = int(os.environ.get("MGMT_PORT", "8080"))

# Runtime directory for dumps (provided by systemd RuntimeDirectory=)
DUMP_DIR = Path(os.environ.get("RUNTIME_DIRECTORY", "/run/erigon_watchdog"))

# D-Bus connection
bus = None
manager = None

# Shared state (protected by lock)
state_lock = threading.Lock()
state = {
    "active_threshold": CONFIG_THRESHOLD,
    "current_drift": None,
    "is_restarted": False,
    "last_restart": None,
    "restart_count": 0,
    "start_time": datetime.now().isoformat(),
}


class MgmtHandler(BaseHTTPRequestHandler):
    """HTTP handler for management API."""

    def log_message(self, format, *args):
        """Log to stdout instead of stderr."""
        print(f"MGMT: {args[0]}")

    def send_json(self, data, status=200):
        """Send JSON response."""
        body = json.dumps(data, indent=2).encode("utf-8")
        self.send_response(status)
        self.send_header("Content-Type", "application/json")
        self.send_header("Content-Length", len(body))
        self.end_headers()
        self.wfile.write(body)

    def do_GET(self):
        """Handle GET requests."""
        if self.path == "/status":
            with state_lock:
                response = {
                    "config_threshold": CONFIG_THRESHOLD,
                    "active_threshold": state["active_threshold"],
                    "paused": state["active_threshold"] == 0,
                    "current_drift": state["current_drift"],
                    "is_restarted": state["is_restarted"],
                    "last_restart": state["last_restart"],
                    "restart_count": state["restart_count"],
                    "start_time": state["start_time"],
                    "uptime_seconds": int((datetime.now() - datetime.fromisoformat(state["start_time"])).total_seconds()),
                }
            self.send_json(response)
        else:
            self.send_json({"error": "Not found"}, 404)

    def do_POST(self):
        """Handle POST requests."""
        # Normalize /pause and /resume to threshold endpoints
        path = self.path
        if path == "/pause":
            path = "/threshold/0"
        elif path == "/resume":
            path = "/threshold/default"

        if path.startswith("/threshold/"):
            value = path.split("/threshold/")[1]

            with state_lock:
                if value == "default":
                    state["active_threshold"] = CONFIG_THRESHOLD
                    print(f"Threshold reset to default: {CONFIG_THRESHOLD}")
                else:
                    try:
                        new_threshold = int(value)
                        if new_threshold < 0:
                            self.send_json({"error": "Threshold must be >= 0"}, 400)
                            return
                        state["active_threshold"] = new_threshold
                        if new_threshold == 0:
                            print("Restarts PAUSED (threshold set to 0)")
                        else:
                            print(f"Threshold changed to: {new_threshold}")
                    except ValueError:
                        self.send_json({"error": "Invalid threshold value"}, 400)
                        return

                response = {
                    "config_threshold": CONFIG_THRESHOLD,
                    "active_threshold": state["active_threshold"],
                    "paused": state["active_threshold"] == 0,
                }
            self.send_json(response)
        else:
            self.send_json({"error": "Not found"}, 404)


def start_mgmt_server():
    """Start the management HTTP server in a background thread."""
    server = HTTPServer((MGMT_ADDR, MGMT_PORT), MgmtHandler)
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    print(f"Management API listening on http://{MGMT_ADDR}:{MGMT_PORT}")
    return server


def get_systemd_manager():
    """Get D-Bus connection to systemd manager."""
    b = dbus.SystemBus(private=True)
    systemd1 = b.get_object("org.freedesktop.systemd1", "/org/freedesktop/systemd1")
    mgr = dbus.Interface(systemd1, "org.freedesktop.systemd1.Manager")
    return b, mgr


def http_get(url, timeout=10):
    """HTTP GET using urllib."""
    req = urllib.request.Request(
        url, headers={"User-Agent": "Python/3.13 aiohttp/3.10.11"}
    )
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        return resp.read().decode("utf-8")


def http_post_json(url, data, timeout=10):
    """HTTP POST JSON using urllib."""
    payload = json.dumps(data).encode("utf-8")
    req = urllib.request.Request(
        url,
        data=payload,
        headers={
            "Content-Type": "application/json",
            "User-Agent": "Python/3.13 aiohttp/3.10.11",
        },
    )
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        return json.loads(resp.read().decode("utf-8"))


def get_block_number(url):
    """Get current block number from an Ethereum RPC endpoint."""
    try:
        data = {"jsonrpc": "2.0", "method": "eth_blockNumber", "params": [], "id": 1}
        result = http_post_json(url, data)
        return int(result["result"], 16)
    except Exception as e:
        print(f"Error getting block number from {url}: {e}")
        return None


def get_block_drift():
    """Calculate block drift between local and reference."""
    reference = get_block_number(REFERENCE_URL)
    local = get_block_number(LOCAL_URL)

    if reference is None or local is None:
        return None

    return reference - local


def check_recent_logs(pattern, minutes=5):
    """Check if pattern appears in recent Erigon logs."""
    try:
        j = journal.Reader()
        j.add_match(_SYSTEMD_UNIT="erigon.service")
        j.seek_realtime(datetime.now() - timedelta(minutes=minutes))

        pattern_lower = pattern.lower()
        for entry in j:
            if pattern_lower in entry['MESSAGE'].lower():
                return True
        return False
    except Exception as e:
        print(f"Error checking logs: {e}")
        return False


def capture_iostat(timestamp):
    """Capture iostat for disk I/O analysis."""
    try:
        iostat_file = DUMP_DIR / f"iostat_{timestamp}.txt"
        result = subprocess.run(
            ["iostat", "-x", "1", "3"], capture_output=True, text=True, timeout=10
        )
        iostat_file.write_text(result.stdout)
        print(f"Captured iostat to {iostat_file}")
    except Exception as e:
        print(f"Failed to capture iostat: {e}")


def capture_pprof_dump(timestamp):
    """Capture goroutine dump for post-mortem analysis."""
    try:
        dump_file = DUMP_DIR / f"goroutine_{timestamp}.txt"
        dump_content = http_get(
            f"{PPROF_URL}/debug/pprof/goroutine?debug=2", timeout=10
        )
        dump_file.write_text(dump_content)
        print(f"Captured pprof dump: {dump_file}")

        # Also capture a summary to logs for quick analysis
        goroutine_states = {}
        for line in dump_content.split("\n"):
            if line.startswith("goroutine ") and "[" in line:
                state_str = line.split("[")[1].split("]")[0].split(",")[0]
                goroutine_states[state_str] = goroutine_states.get(state_str, 0) + 1

        mutex_locks = goroutine_states.get("sync.Mutex.Lock", 0)
        if mutex_locks > 0:
            print(f"WARNING: {mutex_locks} goroutines blocked on sync.Mutex.Lock")

        top_states = sorted(goroutine_states.items(), key=lambda x: -x[1])[:5]
        print(f"Goroutine states: {dict(top_states)}")
    except Exception as e:
        print(f"Error capturing pprof dump: {e}")


def capture_erigon_logs(timestamp):
    """Capture recent Erigon logs for context."""
    try:
        log_file = DUMP_DIR / f"erigon_logs_{timestamp}.txt"
        j = journal.Reader()
        j.add_match(_SYSTEMD_UNIT="erigon.service")
        j.seek_realtime(datetime.now() - timedelta(minutes=10))

        lines = [f"{e['__REALTIME_TIMESTAMP']} {e['MESSAGE']}" for e in j]
        log_file.write_text('\n'.join(lines))
        print(f"Captured Erigon logs: {log_file}")
    except Exception as e:
        print(f"Error capturing Erigon logs: {e}")


def restart_service(service_name):
    """Restart a systemd service via D-Bus. Returns True on success."""
    global bus, manager
    print(f"Restarting {service_name}...")
    try:
        manager.RestartUnit(f"{service_name}.service", "fail")
        print(f"{service_name} restarted successfully")
        return True
    except dbus.exceptions.DBusException as e:
        print(f"D-Bus error restarting {service_name}: {e}")
        # Reinitialize connection for next attempt
        try:
            if bus:
                bus.close()
        except Exception:
            pass
        try:
            bus, manager = get_systemd_manager()
        except Exception as e2:
            print(f"Failed to reconnect to D-Bus: {e2}")
        return False


def cleanup_old_dumps(max_files=20):
    """Keep only the most recent dump files."""
    try:
        dumps = sorted(DUMP_DIR.glob("*.txt"), key=lambda p: p.stat().st_mtime)
        while len(dumps) > max_files:
            oldest = dumps.pop(0)
            oldest.unlink()
            print(f"Cleaned up old dump: {oldest.name}")
    except Exception as e:
        print(f"Error cleaning up dumps: {e}")


def main():
    global bus, manager

    if not REFERENCE_URL:
        print("ERROR: REFERENCE_URL environment variable not set")
        sys.exit(1)

    # Initialize D-Bus connection
    bus, manager = get_systemd_manager()

    # Start management API server
    start_mgmt_server()

    print(f"Erigon Watchdog v3 starting")
    print(f"  Reference: {REFERENCE_URL}")
    print(f"  Local: {LOCAL_URL}")
    print(f"  Threshold: {CONFIG_THRESHOLD}")
    print(f"  External CL: {EXTERNAL_CL} ({CL_SERVICE})")
    print(f"  Dump directory: {DUMP_DIR}")

    while True:
        drift = get_block_drift()

        # Update shared state
        with state_lock:
            state["current_drift"] = drift
            active_threshold = state["active_threshold"]
            is_restarted = state["is_restarted"]

        if drift is None:
            print("Could not determine drift")
            time.sleep(60)
            continue

        # Check if paused (threshold == 0)
        if active_threshold == 0:
            print(f"{drift} (paused)")
            time.sleep(60)
            continue

        if drift > active_threshold:
            # Above threshold
            if is_restarted:
                # Already restarted, wait for recovery
                print(f"{drift}")
                time.sleep(60)
                continue

            print(f"{drift} (threshold: {active_threshold})")

            # === Drift exceeds threshold - diagnose and act ===
            DUMP_DIR.mkdir(parents=True, exist_ok=True)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

            # Check 1: Aggregation in progress? (wait it out)
            if check_recent_logs("aggregat"):
                print("Aggregation in progress, waiting...")
                time.sleep(60)
                continue

            # Check 2: CL communication failure? (restart CL, not Erigon)
            if EXTERNAL_CL and check_recent_logs("no CL requests"):
                print("Detected CL communication failure")
                capture_iostat(timestamp)
                capture_pprof_dump(timestamp)
                capture_erigon_logs(timestamp)
                if restart_service(CL_SERVICE):
                    with state_lock:
                        state["is_restarted"] = True
                        state["last_restart"] = datetime.now().isoformat()
                        state["restart_count"] += 1
                time.sleep(60)
                continue

            # Default: Restart Erigon
            print(f"restarting Erigon")
            capture_iostat(timestamp)
            capture_pprof_dump(timestamp)
            capture_erigon_logs(timestamp)
            if restart_service("erigon"):
                with state_lock:
                    state["is_restarted"] = True
                    state["last_restart"] = datetime.now().isoformat()
                    state["restart_count"] += 1

            # Cleanup old dumps periodically
            cleanup_old_dumps()
        else:
            # Below threshold - reset restart flag if possible
            print(f"{drift}")
            if drift <= 5:
                with state_lock:
                    state["is_restarted"] = False

        time.sleep(60)


if __name__ == "__main__":
    main()
